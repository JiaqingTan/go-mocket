### Setup tests

***

To setup tests, you need register driver and override DB instance used across a codebase.
```go
import (
  "database/sql"
  mocket "github.com/selvatico/go-mocket"
  "github.com/jinzhu/gorm"
)

func SetupTests() *sql.DB { // or *gorm.DB
  mocket.Catcher.Register() // Safe register. Allowed multiple calls to save
  // GORM
  db, err := gorm.Open(mocket.DRIVER_NAME, "connection_string") // Could be any connection string
  DB = db

   // OR
   // Regular sql package usage
   db, err := sql.Open(mocket.DRIVER_NAME, "connection_string")

   return db
}
```

In the snippet above intentionally skipped assigning to proper variable DB instance. One of the assumptions used that every project has one DB instance at the time, overriding it with FakeDriver will do its job.

### Simple chain usage

***

```go
// Function to tests
func GetUsers(db *sql.DB) []map[string]string {
	var res []map[string]string
	age := 27
	rows, err := db.Query("SELECT name FROM users WHERE age=?", age)
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	for rows.Next() {
		var name string
		var age string
		if err := rows.Scan(&name, &age); err != nil {
			log.Fatal(err)
		}
		row := map[string]string{"name": name, "age": age}
		res = append(res, row)
	}
	if err := rows.Err(); err != nil {
		log.Fatal(err)
	}
	return res
}

// Test function
func TestResponses(t *testing.T) {
	SetupTests()

	t.Run("Simple SELECT caught by query", func(t *testing.T) {
		Catcher.Logging = false
		commonReply := []map[string]interface{}{{"name": "FirstLast", "age": "30"}}
		Catcher.Reset().NewMock().WithQuery(`SELECT name FROM users WHERE`).WithReply(commonReply)
		result := GetUsers(DB) // GLobal or local variable
		if len(result) != 1 {
			t.Errorf("Returned sets is not equal to 1. Received %d", len(result))
		}
		if result[0]["age"] != "30" {
			t.Errorf("Age is not equal. Got %v", result[0]["age"])
		}
	})
}
```
In example above we create New mock via `.NewMock()` and attach query pattern which will be used to catch query.`.WithReply()` specifies which response will be provided during mock of this request.
As `Catcher` is global variable without calling `.Reset()` this mock will be applied to all tests and queries if the pattern will be matched.

### Usage via `FakeResponse` object

We will take `GetUsers` from the previous example to show how could be used attachment of mock directly to Catcher object

```go
t.Run("Simple select with direct object", func(t *testing.T) {
	Catcher.Reset()
	Catcher.Attach([]*FakeResponse{
		{
			Pattern:"SELECT name FROM users WHERE", // the same as .WithQuery()
			Response: commonReply, // the same as .WithReply
			Once: false, // To not use it twice if true
		},
	})
	result := GetUsers(DB)
	if len(result) != 1 {
		t.Errorf("Returned sets is not equal to 1. Received %d", len(result))
	}
	if result[0]["age"] != "30" {
		t.Errorf("Age is not equal. Got %v", result[0]["age"])
	}
})
```

### GORM example

Usage of GORM is completely the same as it would be without it. You need to understand which query will be generated by GORM and mock or mock just by arguments. In this case, you need to pay attention to order of arguments as GORM will arrange them not in order you can provide them


### Catch by arguments

The query could be caught by provided arguments even without specifying query pattern to match.
Please notice 2 important facts:

* Order is very important
* GORM will re-order arguments according to fields in struct defined to describe you models.

```go
t.Run("Catch by arguments", func(t *testing.T) {
   Catcher.Reset().NewMock().WithArgs(int64(27)).WithReply(commonReply)
   result := GetUsers(DB)
   if len(result) != 1 {
	t.Fatalf("Returned sets is not equal to 1. Received %d", len(result))
   }
   // all other check from reply     
})
```

### Match only once

Mock marked as only once and do not return next time
```go
t.Run("Once", func(t *testing.T) {
   Catcher.Reset()
   Catcher.Attach([]*FakeResponse{
    {
	Pattern:"SELECT name FROM users WHERE",
	Response: commonReply,
	Once: true, // could be done via chaining .OneTime()
    },
    })
    GetUsers(DB) // Trigger once to use this mock
    result := GetUsers(DB) // trigger second time to receive empty results
    if len(result) != 0 {
      t.Errorf("Returned sets is not equal to 0. Received %d", len(result))
    }
})
```

### Insert Id with `.WithId(int64)`

In order to emulate `INSERT` requests, we can mock ID returned with `.WithId(int64)` method.

```go
//Somewhere in the code
func InsertRecord(db *sql.DB) int64  {
   res, err := db.Exec(`INSERT INTO foo VALUES("bar", ?))`, "value")
   if err != nil {
     return 0
   }
   id, _ := res.LastInsertId()
   return id
}

// Test code
t.Run("Last insert id", func(t *testing.T) {
   var mockedId int64
   mockedId = 64
   Catcher.Reset().NewMock().WithQuery("INSERT INTO foo").WithId(mockedId)
   returnedId := InsertRecord(DB)
   if returnedId != mockedId {
     t.Fatalf("Last insert id not returned. Expected: [%v] , Got: [%v]", mockedId, returnedId)
   }
})
```

### Emulate exceptions

You could emulate exceptions or error during the request by saying it fake `FakeResponse` object.
Please notice that to fire error on `SELECT` you need to use `WithQueryException()`, for queries which do not return results you need to use `.WithExecException()`

Example: 
```go
// Somewhere in the code
func GetUsersWithError(db *sql.DB) error {
  age := 27
  _, err := db.Query("SELECT name FROM users WHERE age=?", age)
  return err
}

func CreateUsersWithError(db *sql.DB) error {
	age := 27
	_, err := db.Query("INSERT INTO users (age) VALUES (?) ", age)
	return err
}

// Test
t.Run("Fire Query error", func(t *testing.T) {
	Catcher.Reset().NewMock().WithArgs(int64(27)).WithQueryException()
	err := GetUsersWithError(DB)
	if err == nil {
	   t.Fatal("Error not triggered")
	}
})

t.Run("Fire Execute error", func(t *testing.T) {
   Catcher.Reset().NewMock().WithQuery("INSERT INTO users (age)").WithQueryException()
   err := CreateUsersWithError(DB)
   if err == nil {
	 t.Fatal("Error not triggered")
   }
})
```
### Callbacks

Besides that, you can catch and attach callbacks when mock is used

__More examples coming....__